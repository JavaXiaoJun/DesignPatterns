#装饰模式的概念
```
    装饰模式（Decorator）,动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活
```

#变通
```
    如果只有一个 ConcreteComponent 类，就没必要抽象出 Component类，此时 Decorator 类可以是 ConcreteComponent 的一个子类；
    同样，如果只有一个 ConcreteDecorator 类看，那么就没有必要抽象出单独的 Decorator 类，而把 Decorator 的职责合并到 ConcreteDecorator 类。
```

#总结
- 装饰模式是为已有功能动态添加更多功能的一种方式
- 装饰模式把每个需要装饰的功能放在单独的类中，并让这个类包装所需要装饰的对象，当需要执行特殊行为时，用户代码就可以在运行时根据需要有选择地、按顺序地使用装饰器

#装饰模式的优点
- 装饰模式有效的把类的核心功能和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑


#装饰模式 VS 代理模式
- 不同点
    1. 被封装对象的创建：代理类所能代理的类完全由代理类确定；装饰类装饰的对象由用户确定。
    2. 用户对被封装对象的感知：被代理对象由代理类创建，用户甚至不需要知道被代理类的存在；被装饰的对象由用户创建并传给装饰对象，客户明确知道被装饰对象。
    4. 场景方面：装饰模式侧重“动态”地“修饰”，动态的装饰被装饰对象；代理模式侧重“静态”地一次性“增强或削弱”，静态的限制被对代理对象访问或增强被代理对象
- 相同点
    1. 都是继承相同的接口
    2. 都可以用来增强或削弱对象的功能

- 总结
    - 装饰模式：动态 多次性 修饰 封装对象
    - 代理模式：静态 一次性 增强 封装对象